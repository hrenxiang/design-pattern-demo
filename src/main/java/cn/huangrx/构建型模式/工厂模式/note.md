我们构建对象时，常常直接 new 一个对象出来， 虽然看起来没什么，但这其实属于 **硬编码**。

每当我们在调用者中 new 一个对象，调用者就需要多知道一个类，这就增加了类与类间的耦合，而通过设计模式将其封装就能解决这些问题。

工厂模式一共分为三种，简单工厂模式、工厂方法模式、抽象工厂模式。

#### 简单工厂模式
举个例子，new 对象就相当于我们如果需要一只鸡，我们需要知道鸡的构造方法；如果需要一只鸭，我们还需要知道鸭的构造方法。

这样对我们来说显的太过复杂，需要记忆很多额外的东西。更好的实现方式就是通过一个工厂，我们只需要告诉工厂我们需要什么，它就会给我们创造什么。

```java

```
简单工厂模式就是让一个工厂类承担构建所有对象的职责。

因此简单工厂的弊端也显而易见：
- 如果需要生产的产品过多，工厂类会过于庞大。
- 每一个产品的创建过程需要修改时，都需要改动此工厂类，违背了单一职责原则。
- 如果需要添加新的产品，需要修改工厂类，违背了开闭原则。



#### 工厂方法模式
为了解决 简单工厂模式中存在的问题，工厂方法模式应运而生，它规定每一种产品都有自己的产品工厂。

比如创建鸡有专属的鸡厂，创建鸭有专属的鸭厂。 这样即使产品过多，也只需要添加新的专属工厂（解决工厂类庞大以及开闭原则），修改也只需要修改单一产品的专属工厂（解决单一职责）

那这样 和我们直接 new 对象出来有什么区别呢？
当构建过程相当复杂时，工厂可以将构建过程封装起来，调用者可以很方便的直接使用，还是可以帮助我们减少重复的代码量的。

